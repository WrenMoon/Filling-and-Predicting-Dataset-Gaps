import torch
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from darts import TimeSeries
from darts.dataprocessing.transformers import Scaler
from darts.models import TransformerModel
from darts.datasets import AirPassengersDataset

import warnings
warnings.filterwarnings("ignore")
import logging
logging.disable(logging.CRITICAL)

# Load and prepare data
series = AirPassengersDataset().load().astype(np.float32)

# Normalize the time series
scaler = Scaler()
series_scaled = scaler.fit_transform(series)

print(f"The 'air passengers' dataset has {len(series)} data points.")

# Define and train the model
my_model = TransformerModel(
    input_chunk_length=12,
    output_chunk_length=1,
    batch_size=32,
    n_epochs=200,
    model_name="air_transformer",
    nr_epochs_val_period=10,
    d_model=16,
    nhead=8,
    num_encoder_layers=2,
    num_decoder_layers=2,
    dim_feedforward=128,
    dropout=0.1,
    activation="relu",
    random_state=42,
    save_checkpoints=True,
    force_reset=True,
)
my_model.fit(series=series_scaled, verbose=True)

# Function to create a gap, forecast and backtest
def fill_gap_with_forecast_backtest(model, series, gap_start_idx, gap_end_idx):
    # Split the series into segments before and after the gap
    series_before_gap = series[:gap_start_idx]
    series_after_gap = series[gap_end_idx:]
    gap_len = gap_end_idx - gap_start_idx
    forecast_len = gap_len // 2  # Forecast up to midpoint of the gap
    backtest_len = gap_len - forecast_len  # Backtest the remaining half

    # Forecast up to the midpoint of the gap
    forecast_series = model.predict(n=forecast_len, series=series_before_gap)

    # Concatenate to create a continuous series up to the midpoint
    mid_series = series_before_gap.concatenate(forecast_series)

    # Check time index names for debugging
    print("Series Before Gap Time Index:", series_before_gap.time_index)
    print("Forecast Series Time Index:", forecast_series.time_index)
    print("Mid Series Time Index:", mid_series.time_index)

    # Backtest for the second half of the gap
    backtest_series = model.historical_forecasts(
        series=mid_series,
        start=mid_series.time_index[-1],  # Start forecasting from the last timestamp of mid_series
        forecast_horizon=1,
        retrain=False,
        verbose=True,
    )[:backtest_len]

    # Check backtest series time index
    print("Backtest Series Time Index:", backtest_series.time_index)

    # Concatenate the forecast and backtest results to fill the entire gap
    gap_filled_series = mid_series.concatenate(backtest_series).concatenate(series_after_gap)

    # Plot results
    plt.figure(figsize=(10, 6))
    series.plot(label="Actual")
    gap_filled_series.plot(label="Gap Filled (Forecast + Backtest)", color="orange")
    plt.axvline(series.time_index[gap_start_idx], color="green", linestyle="--", label="Gap Start")
    plt.axvline(series.time_index[gap_end_idx - 1], color="red", linestyle="--", label="Gap End")
    plt.legend()
    plt.title("Gap filling with Forecast (first half) & Backtest (second half)")
    plt.show()

# Define gap start and end indices
gap_start_idx = 90  # Adjust as needed
gap_end_idx = 110   # Adjust as needed
fill_gap_with_forecast_backtest(my_model, series_scaled, gap_start_idx, gap_end_idx)
